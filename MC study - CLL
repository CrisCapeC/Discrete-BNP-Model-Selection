################################################################
######### Monte Carlo Study for Discrete BNPMS model ##########
#########            Scenario: Cloglog              ##########
#############################################################
rm(list = ls());gc()


######################################################
###########          Functions         ##############
####################################################

###### Discrete_BNPMS algorithm
Discrete_BNPMS = function(y, X, prior_params, n_iter, n_burn){
  
  #thresholds
  a = c(-Inf,0,Inf)
  
  #Datasize
  n = nrow(X)
  p = ncol(X)
  
  # Objects
  ess = n_iter-n_burn
  gamma_sim = matrix(0, ncol = ess, nrow = p) #[Covariate, iteration]
  
  #Prior hyperparameters
  beta0 = prior_params$beta0
  kappa = prior_params$kappa
  a_alpha = prior_params$a_alpha
  b_alpha = prior_params$b_alpha
  rho = prior_params$rho
  
  #Womack log-prior 
  out = rep(-Inf, p)
  out[p] = 0
  for(l in (p-2):0){
    j = (l+1):(p-1)
    bb = out[j+1] + lgamma(j+1) - lgamma(l+1) - lgamma(j+1-l) + log(rho)
    out[l+1] = log(sum(exp(bb-max(bb)))) + max(bb)
    out = out - max(out) -log(sum(exp(out-max(out))))		
  }
  prior_gamma = out + lbeta(c(1:p), p-c(0:(p-1))) + log(p)
  
  
  #### Initial values
  alpha = 1
  q = ceiling(p/2) #A half of predictor
  gamma = c(1, c(rep(1,q-1),rep(0,p-q))[sample(1:(p-1), p-1, replace = F)]) 
  X_gamma = X[, gamma == 1,drop = F]
  beta0_gamma = beta0[gamma == 1]
  s = sample(1:4, n, replace = T)
  n_groups = tabulate(s, nbins = max(s)) #Number of units per cluster
  k = max(s)
  z = y
  
  for(t in 1:n_burn){
    
    #Label and latent variables
    s_z_ngroups = s_z_simulationCPP(y = y, X_gamma = X_gamma, s = s, k = k, n_groups = n_groups, z = z, n = n, a = a,
                                    beta0_gamma = beta0_gamma, kappa = kappa,
                                    alpha = alpha, q = q)
    
    n_groups = s_z_ngroups$n_groups
    s = s_z_ngroups$s
    z = s_z_ngroups$z
    k = s_z_ngroups$k
    
    #Contraction parameter (alpha)
    logeta = log(rbeta(1, alpha + 1, n))
    pi1 = (a_alpha + k - 1)/(n*(b_alpha-logeta) + a_alpha + k - 1)
    alpha = rgamma(1, a_alpha + k - 1 + rbinom(1, 1, pi1), b_alpha - logeta)
    
    
    #Selector parameter (gamma)
    gamma_and_q = gamma_simulationCPP(gamma = gamma, p = p, q = q, X = X, s = s, z = z, k = k,
                                      n_groups = n_groups, beta0 = beta0, kappa = kappa,
                                      prior_gamma = prior_gamma)
    gamma = gamma_and_q$gamma
    q = gamma_and_q$q
    X_gamma = X[, gamma == 1,drop = F]
    beta0_gamma = beta0[gamma == 1]
    
  }
  
  for(t in 1:ess){
    
    #Label and latent variables
    s_z_ngroups = s_z_simulationCPP(y = y, X_gamma = X_gamma, s = s, k = k, n_groups = n_groups, z = z, n = n, a = a,
                                    beta0_gamma = beta0_gamma, kappa = kappa,
                                    alpha = alpha, q = q)
    
    n_groups = s_z_ngroups$n_groups
    s = s_z_ngroups$s
    z = s_z_ngroups$z
    k = s_z_ngroups$k
    
    #Contraction parameter (alpha)
    logeta = log(rbeta(1, alpha + 1, n))
    pi1 = (a_alpha + k - 1)/(n*(b_alpha-logeta) + a_alpha + k - 1)
    alpha = rgamma(1, a_alpha + k - 1 + rbinom(1, 1, pi1), b_alpha - logeta)
    
    
    #Selector parameter (gamma)
    gamma_and_q = gamma_simulationCPP(gamma = gamma, p = p, q = q, X = X, s = s, z = z, k = k,
                                      n_groups = n_groups, beta0 = beta0, kappa = kappa,
                                      prior_gamma = prior_gamma)
    gamma = gamma_and_q$gamma
    q = gamma_and_q$q
    X_gamma = X[, gamma == 1,drop = F]
    beta0_gamma = beta0[gamma == 1]
    
    #Save results
    gamma_sim[,t] = gamma
    
  }
  
  return(gamma_sim)
  
}

##### Simulation function
#replica_id = 1:n_MC
#seeds: n_MCx32 matrix with random seeds (between 1 to 9999)
#n: samplesize
#true_params: True parameters for data generation
#true_gamma: 6x32 matrix with all models
#n_iter: Length of chains
#n_burn: burn-in period
MonteCarloSimulation = function(replica_id, seeds, n, true_params, true_gamma,
                                prior_params, n_iter, n_burn){
  
  beta = true_params$beta*true_gamma
  
  model_selection = array(0,dim = c(6,n_iter-n_burn,32))
  dimnames(model_selection) = list(NULL,NULL,apply(true_gamma, 2, paste0, collapse = ""))
  for(j in 1:32){
    #seed
    set.seed(seeds[replica_id,j])
    
    #data
    beta_gamma = beta[,j]
    X = cbind(1,runif(n),rnorm(n,0.5,0.5),rgamma(n,1,2),rbinom(n,1,0.5),rbinom(n,1,0.75))
    y = rbinom(n,1, 1 - exp(-exp(X%*%beta_gamma)))
    
    #model fit
    prior_params$beta0 = c(mean(y), rep(0,5))
    model_selection[,,j] = Discrete_BNPMS(y = y, X = X, prior_params,
                                          n_iter = n_iter, n_burn = n_burn) #6x8000 matrix
    
    
  }
  
  saveRDS(model_selection, file = paste0("MonteCarloStudy_Cloglog_n",n,"_",replica_id,".rds"))
  
  return(list(replica = replica_id, model_selection = model_selection))
}


######################################################
###########      MonteCarlo study      ##############
####################################################
library(parallel)

##### Simulation setup
n_MC = 100 #MonteCarlo replicas
n = 800 #Sample size
true_gamma_aux = t(cbind(1,expand.grid(rep(list(c(0, 1)), 5)))) #All possible models (disordered)
true_gamma = true_gamma_aux[, order(colSums(true_gamma_aux))];rownames(true_gamma) = NULL
true_params = list(beta = c(-1, -2, 1.5, -1.5, 1.2, -1.2))
prior_params = list(kappa = 10, a_alpha = 0.1, b_alpha = 0.1, rho = 1) #Prior hyperparameters
n_iter = 10000 #Length of chains
n_burn = 2000 #burn-in period
if(n == 200){
  set.seed(2312) #n=200
} else if(n == 400){
  set.seed(4312) #n=400
} else{
  set.seed(8312) #n=800
}
seeds = matrix(sample(1:9999, n_MC*32, replace = F), nrow = n_MC, ncol = 32)


##### Clusters setup for parallel processing
n_cores = detectCores()  #Number of cores
clu = makeCluster(n_cores)  #Create de cluster
#Including dependences
clusterEvalQ(clu,{
  library(Rcpp)
  library(RcppArmadillo)
  sourceCpp("C:/Users/capet/Documents/Doctorado en Estadística/Tesis/Discrete BNPMS/CPPFunctions_for_BINARY_BNPMS_Neals_approach.cpp")
})
#Exporting functions and objects
clusterExport(clu, varlist = c("MonteCarloSimulation", "Discrete_BNPMS",
                               "seeds", "n", "true_params", "true_gamma", "prior_params",
                               "n_iter", "n_burn"))

##### MonteCarlo study
library(tictoc)
tic()
MonteCarloStudy = parLapply(clu, X = 1:n_MC,
                            fun = function(i) MonteCarloSimulation(i, seeds, n,
                                                                   true_params, true_gamma, prior_params,
                                                                   n_iter, n_burn)
)
toc()
#A list of n_MC objects.
#Each object is in turn a list with: replica_id, model selection array (p(6), ess(8000), model space size (32))
stopCluster(clu) #Closing cluster


#Processing results
Model_Selection = matrix(0, nrow = 32, ncol = n_MC)
colnames(Model_Selection) = paste0("replica",1:n_MC)
gamma_char = apply(true_gamma, 2, paste0, collapse = "") #collapsed (label)
model_probabilities_mean = matrix(0, nrow = 32, ncol = 32)
bar = txtProgressBar(min = 0, max = n_MC, style = 3) #Progress bar
for(i in 1:n_MC){
  
  #posterior probabilities under each model
  gamma_posterior_distributions = matrix(0,nrow = 32, ncol = 32)
  colnames(gamma_posterior_distributions) = rownames(gamma_posterior_distributions) = gamma_char
  for(j in 1:32){
    gamma_aux = apply(MonteCarloStudy[[i]]$model_selection[,,j], 2, paste0, collapse = "") #transformation of gamma_sim to a 2000x1 vector
    prob_gamma = as.numeric(table(gamma_aux))/length(gamma_aux) #Model probabilities
    names(prob_gamma) = names(table(gamma_aux))
    gamma_posterior_distributions[j,names(prob_gamma)] = t(prob_gamma) #32x1 vector of model posterior probabilities under model j
    
    gamma_sim_repi_modelj = MonteCarloStudy[[i]]$model_selection[,,j] #ith replica, jth model, gamma results
    gamma_aux = apply(gamma_sim_repi_modelj, 2, paste0, collapse = "")
    Model_Selection[j,i] = names(sort(table(gamma_aux)/8000, decreasing = TRUE))[1] #Name of most likely model
  }
  model_probabilities_mean = model_probabilities_mean + gamma_posterior_distributions/n_MC
  
  setTxtProgressBar(bar, i)
}
close(bar)

data.frame(true_model = apply(true_gamma, 2, paste0, collapse = ""), Freq = rowSums(Model_Selection == apply(true_gamma, 2, paste0, collapse = ""))/n_MC)

fields::image.plot(1:32, 1:32, t(model_probabilities_mean), col = colorRampPalette(c("white", rgb(0, 0.3, 0.3)))(100),
                   xlab = "Selected model", ylab = "True model", main = "n = 200",
                   axes = FALSE, axis.args = list(tck = 0, lwd = 0, mgp = c(1,0.5,0)),
                   zlim = c(0,1), legend.shrink = 0.6)
axis(1, at = 1:32, labels = gamma_char, las = 2, cex.axis = 0.5, tick = FALSE)
axis(2, at = 1:32, labels = gamma_char, las = 2, cex.axis = 0.5, tick = FALSE)
for(j in 0:32){
  abline(h = j + 0.5, col = "grey60", lwd = 0.5)
  abline(v = j + 0.5, col = "grey60", lwd = 0.5)
}




rm(list = ls());gc()
#Each replicate was saving separately. Here we join them for each sample size.
models_aux = t(cbind(1, expand.grid(rep(list(c(0, 1)), 5)))) #All possible models
models_true = models_aux[, order(colSums(models_aux))] #ordening by complexity
all_gamma_strings = apply(models_true, 2, paste0, collapse = "") #collapsed (label)
MonteCarloStudy_Cloglog_n800 = vector("list", 100)
bar = txtProgressBar(min = 0, max = 100, style = 3) #Progress bar
for(i in 1:100){
  
  #gamma simulation under each model
  file_route = paste0("C:/Users/capet/Documents/Doctorado en Estadística/Tesis/Discrete BNPMS/Monte Carlo Study/Cloglog/MonteCarloStudy_Cloglog_n800_",i,".rds")
  MonteCarloStudy_Cloglog_n800[[i]]$model_selection = model_selection = readRDS(file_route)
  
  #Object to save the distribution of gamma
  gamma_posterior_distributions = matrix(0, nrow = 32, ncol = 32)
  colnames(gamma_posterior_distributions) = rownames(gamma_posterior_distributions) = all_gamma_strings
  
  #posterior probabilities under each model
  for(j in 1:32){
    gamma_aux = apply(model_selection[,,j], 2, paste0, collapse = "") #transformation of gamma_sim to a 6000x1 vector
    prob_gamma = as.numeric(table(gamma_aux))/length(gamma_aux) #Model probabilities
    names(prob_gamma) = names(table(gamma_aux))
    gamma_posterior_distributions[j,names(prob_gamma)] = t(prob_gamma) #32x1 vector of model posterior probabilities under model j
  }
  
  
  MonteCarloStudy_Cloglog_n800[[i]]$gamma_posterior_distributions = gamma_posterior_distributions
  
  setTxtProgressBar(bar, i)
}
close(bar)

saveRDS(MonteCarloStudy_Cloglog_n800, file = paste0("MonteCarloStudy_Cloglog_n800.rds"))



### FIN.
